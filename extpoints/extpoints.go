// generated by go-extpoints -- DO NOT EDIT
package extpoints

import (
	"reflect"
	"runtime"
	"strings"
	"sync"
)

var extRegistry = &registryType{m: make(map[string]*extensionPoint)}

type registryType struct {
	sync.Mutex
	m map[string]*extensionPoint
}

// Top level registration

func extensionTypes(extension interface{}) []string {
	var ifaces []string
	typ := reflect.TypeOf(extension)
	for name, ep := range extRegistry.m {
		if ep.iface.Kind() == reflect.Func && typ.AssignableTo(ep.iface) {
			ifaces = append(ifaces, name)
		}
		if ep.iface.Kind() != reflect.Func && typ.Implements(ep.iface) {
			ifaces = append(ifaces, name)
		}
	}
	return ifaces
}

func RegisterExtension(extension interface{}, name string) []string {
	extRegistry.Lock()
	defer extRegistry.Unlock()
	var ifaces []string
	for _, iface := range extensionTypes(extension) {
		if extRegistry.m[iface].register(extension, name) {
			ifaces = append(ifaces, iface)
		}
	}
	return ifaces
}

func UnregisterExtension(name string) []string {
	extRegistry.Lock()
	defer extRegistry.Unlock()
	var ifaces []string
	for iface, extpoint := range extRegistry.m {
		if extpoint.unregister(name) {
			ifaces = append(ifaces, iface)
		}
	}
	return ifaces
}

// Base extension point

type extensionPoint struct {
	sync.Mutex
	iface      reflect.Type
	extensions map[string]interface{}
}

func newExtensionPoint(iface interface{}) *extensionPoint {
	ep := &extensionPoint{
		iface:      reflect.TypeOf(iface).Elem(),
		extensions: make(map[string]interface{}),
	}
	extRegistry.Lock()
	extRegistry.m[ep.iface.Name()] = ep
	extRegistry.Unlock()
	return ep
}

func (ep *extensionPoint) lookup(name string) interface{} {
	ep.Lock()
	defer ep.Unlock()
	ext, ok := ep.extensions[name]
	if !ok {
		return nil
	}
	return ext
}

func (ep *extensionPoint) all() map[string]interface{} {
	ep.Lock()
	defer ep.Unlock()
	all := make(map[string]interface{})
	for k, v := range ep.extensions {
		all[k] = v
	}
	return all
}

func (ep *extensionPoint) register(extension interface{}, name string) bool {
	ep.Lock()
	defer ep.Unlock()
	if name == "" {
		typ := reflect.TypeOf(extension)
		if typ.Kind() == reflect.Func {
			nameParts := strings.Split(runtime.FuncForPC(
				reflect.ValueOf(extension).Pointer()).Name(), ".")
			name = nameParts[len(nameParts)-1]
		} else {
			name = typ.Elem().Name()
		}
	}
	_, exists := ep.extensions[name]
	if exists {
		return false
	}
	ep.extensions[name] = extension
	return true
}

func (ep *extensionPoint) unregister(name string) bool {
	ep.Lock()
	defer ep.Unlock()
	_, exists := ep.extensions[name]
	if !exists {
		return false
	}
	delete(ep.extensions, name)
	return true
}

// AmmoProvider

var AmmoProviders = &ammoProviderExt{
	newExtensionPoint(new(AmmoProvider)),
}

type ammoProviderExt struct {
	*extensionPoint
}

func (ep *ammoProviderExt) Unregister(name string) bool {
	return ep.unregister(name)
}

func (ep *ammoProviderExt) Register(extension AmmoProvider, name string) bool {
	return ep.register(extension, name)
}

func (ep *ammoProviderExt) Lookup(name string) AmmoProvider {
	ext := ep.lookup(name)
	if ext == nil {
		return nil
	}
	return ext.(AmmoProvider)
}

func (ep *ammoProviderExt) Select(names []string) []AmmoProvider {
	var selected []AmmoProvider
	for _, name := range names {
		selected = append(selected, ep.Lookup(name))
	}
	return selected
}

func (ep *ammoProviderExt) All() map[string]AmmoProvider {
	all := make(map[string]AmmoProvider)
	for k, v := range ep.all() {
		all[k] = v.(AmmoProvider)
	}
	return all
}

func (ep *ammoProviderExt) Names() []string {
	var names []string
	for k := range ep.all() {
		names = append(names, k)
	}
	return names
}

// ResultListener

var ResultListeners = &resultListenerExt{
	newExtensionPoint(new(ResultListener)),
}

type resultListenerExt struct {
	*extensionPoint
}

func (ep *resultListenerExt) Unregister(name string) bool {
	return ep.unregister(name)
}

func (ep *resultListenerExt) Register(extension ResultListener, name string) bool {
	return ep.register(extension, name)
}

func (ep *resultListenerExt) Lookup(name string) ResultListener {
	ext := ep.lookup(name)
	if ext == nil {
		return nil
	}
	return ext.(ResultListener)
}

func (ep *resultListenerExt) Select(names []string) []ResultListener {
	var selected []ResultListener
	for _, name := range names {
		selected = append(selected, ep.Lookup(name))
	}
	return selected
}

func (ep *resultListenerExt) All() map[string]ResultListener {
	all := make(map[string]ResultListener)
	for k, v := range ep.all() {
		all[k] = v.(ResultListener)
	}
	return all
}

func (ep *resultListenerExt) Names() []string {
	var names []string
	for k := range ep.all() {
		names = append(names, k)
	}
	return names
}

// Limiter

var Limiters = &limiterExt{
	newExtensionPoint(new(Limiter)),
}

type limiterExt struct {
	*extensionPoint
}

func (ep *limiterExt) Unregister(name string) bool {
	return ep.unregister(name)
}

func (ep *limiterExt) Register(extension Limiter, name string) bool {
	return ep.register(extension, name)
}

func (ep *limiterExt) Lookup(name string) Limiter {
	ext := ep.lookup(name)
	if ext == nil {
		return nil
	}
	return ext.(Limiter)
}

func (ep *limiterExt) Select(names []string) []Limiter {
	var selected []Limiter
	for _, name := range names {
		selected = append(selected, ep.Lookup(name))
	}
	return selected
}

func (ep *limiterExt) All() map[string]Limiter {
	all := make(map[string]Limiter)
	for k, v := range ep.all() {
		all[k] = v.(Limiter)
	}
	return all
}

func (ep *limiterExt) Names() []string {
	var names []string
	for k := range ep.all() {
		names = append(names, k)
	}
	return names
}

// Gun

var Guns = &gunExt{
	newExtensionPoint(new(Gun)),
}

type gunExt struct {
	*extensionPoint
}

func (ep *gunExt) Unregister(name string) bool {
	return ep.unregister(name)
}

func (ep *gunExt) Register(extension Gun, name string) bool {
	return ep.register(extension, name)
}

func (ep *gunExt) Lookup(name string) Gun {
	ext := ep.lookup(name)
	if ext == nil {
		return nil
	}
	return ext.(Gun)
}

func (ep *gunExt) Select(names []string) []Gun {
	var selected []Gun
	for _, name := range names {
		selected = append(selected, ep.Lookup(name))
	}
	return selected
}

func (ep *gunExt) All() map[string]Gun {
	all := make(map[string]Gun)
	for k, v := range ep.all() {
		all[k] = v.(Gun)
	}
	return all
}

func (ep *gunExt) Names() []string {
	var names []string
	for k := range ep.all() {
		names = append(names, k)
	}
	return names
}
